递归
=======================

你好，递归
---------

命令式或者面向对象语言的信徒可能很纳闷：怎么都到现在了，还不介绍介绍循环呢？

循环是个神马东西呢？我也不知道。在我们的这个世界里，可没有那些for或者while循环。我们使用一个很傻很天真的东西：递归。

你应该还记得的我们是如何解释“不可变的变量”的吧，如果不记得，赶紧回去复习一下吧。递归也可以用类似的方法来解释。还记得数学上的阶乘的概念吗？某数的阶乘就是将所有小于等于此数的自然数乘起来的积。n的阶乘就是 1 x 2 x 3 x ... x n 或者 n x (n-1) x (n-2) x ... x 1 举个例子：3的阶乘是 3! = 3 x 2 x 1 = 6. 4的阶乘是 4! = 4 x 3 x 2 x 1 = 24. 这个函数可以被非常数学的表示成



上述定义的意思是：如果n的值是0，则结果是1，否则，对每个大于0的数n，结果都是n乘以 n-1的阶乘，这样就可以一直到1.

    4! = 4 x 3!
    4! = 4 x 3 x 2!
    4! = 4 x 3 x 2 x 1!
    4! = 4 x 3 x 2 x 1 x 1

那么这个函数如何翻译成Erlang呢？非常简单。注意n! ， 1 和 n((n-1)!) 以及那些if。这里我们就得到了函数名n! ，守卫（那些if）和函数体（1和 n((n-1)!)）。受语法所限，我们给n!起个新的名字fac(N)，现在我们得到了如下代码：

    -module(recursive).
    -export([fac/1]).
     
    fac(N) when N == 0 -> 1;
    fac(N) when N > 0  -> N*fac(N-1).
