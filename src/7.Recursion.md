递归
=======================

你好，递归
---------

命令式或者面向对象语言的信徒可能很纳闷：怎么都到现在了，还不介绍介绍循环呢？

循环是个神马东西呢？我也不知道。在我们的这个世界里，可没有那些for或者while循环。我们使用一个很傻很天真的东西：递归。

你应该还记得的我们是如何解释“不可变的变量”的吧，如果不记得，赶紧回去复习一下吧。递归也可以用类似的方法来解释。还记得数学上的阶乘的概念吗？某数的阶乘就是将所有小于等于此数的自然数乘起来的积。n的阶乘就是 1 x 2 x 3 x ... x n 或者 n x (n-1) x (n-2) x ... x 1 举个例子：3的阶乘是 3! = 3 x 2 x 1 = 6. 4的阶乘是 4! = 4 x 3 x 2 x 1 = 24. 这个函数可以被非常数学的表示成



上述定义的意思是：如果n的值是0，则结果是1，否则，对每个大于0的数n，结果都是n乘以 n-1的阶乘，这样就可以一直到1.

    4! = 4 x 3!
    4! = 4 x 3 x 2!
    4! = 4 x 3 x 2 x 1!
    4! = 4 x 3 x 2 x 1 x 1

那么这个函数如何翻译成Erlang呢？非常简单。注意n! ， 1 和 n((n-1)!) 以及那些if。这里我们就得到了函数名n! ，守卫（那些if）和函数体（1和 n((n-1)!)）。受语法所限，我们给n!起个新的名字fac(N)，现在我们得到了如下代码：

    -module(recursive).
    -export([fac/1]).
     
    fac(N) when N == 0 -> 1;
    fac(N) when N > 0  -> N*fac(N-1).

这样，我们就得到了阶乘函数的Erlang形式。真的和它的数学形式非常像。如果用上一点模式匹配的话，结果会更加简洁。

    fac(0) -> 1;
    fac(N) when N > 0 -> N*fac(N-1).

非常容易，如果某个问题的自然的数学形式是递归的话，用Erlang来表达这个问题会轻而易举。
简单的说，递归就是“调用自己的函数”。然而，为了不陷入无穷递归，我们还需要停止条件（学术名称 base case）。在这个例子中，停止条件是n等于0。此时，函数停止调用自身，停在此处。

长度
----------

让我们来看一个稍微实用一点的例子，求解列表的长度。那么，我们需要

- 停止条件(base case)
- 一个调用自身的函数
- 要求解的列表

