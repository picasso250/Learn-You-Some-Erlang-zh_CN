递归
=======================

你好，递归
---------

命令式或者面向对象语言的信徒可能很纳闷：怎么都到现在了，还不介绍介绍循环呢？

循环是个神马东西呢？我也不知道。在我们的这个世界里，可没有那些for或者while循环。我们使用一个很傻很天真的东西：递归。

你应该还记得的我们是如何解释“不可变的变量”的吧，如果不记得，赶紧回去复习一下吧。递归也可以用类似的方法来解释。还记得数学上的阶乘的概念吗？某数的阶乘就是将所有小于等于此数的自然数乘起来的积。n的阶乘就是 1 x 2 x 3 x ... x n 或者 n x (n-1) x (n-2) x ... x 1 举个例子：3的阶乘是 3! = 3 x 2 x 1 = 6. 4的阶乘是 4! = 4 x 3 x 2 x 1 = 24. 这个函数可以被非常数学的表示成



上述定义的意思是：如果n的值是0，则结果是1，否则，对每个大于0的数n，结果都是n乘以 n-1的阶乘，这样就可以一直到1.

    4! = 4 x 3!
    4! = 4 x 3 x 2!
    4! = 4 x 3 x 2 x 1!
    4! = 4 x 3 x 2 x 1 x 1

那么这个函数如何翻译成Erlang呢？非常简单。注意n! ， 1 和 n((n-1)!) 以及那些if。这里我们就得到了函数名n! ，守卫（那些if）和函数体（1和 n((n-1)!)）。受语法所限，我们给n!起个新的名字fac(N)，现在我们得到了如下代码：

    -module(recursive).
    -export([fac/1]).
     
    fac(N) when N == 0 -> 1;
    fac(N) when N > 0  -> N*fac(N-1).

这样，我们就得到了阶乘函数的Erlang形式。真的和它的数学形式非常像。如果用上一点模式匹配的话，结果会更加简洁。

    fac(0) -> 1;
    fac(N) when N > 0 -> N*fac(N-1).

非常容易，如果某个问题的自然的数学形式是递归的话，用Erlang来表达这个问题会轻而易举。
简单的说，递归就是“调用自己的函数”。然而，为了不陷入无穷递归，我们还需要停止条件（学术名称 base case）。在这个例子中，停止条件是n等于0。此时，函数停止调用自身，停在此处。

长度
----------

让我们来看一个稍微实用一点的例子，计算列表的长度。那么，我们需要

- 停止条件(base case)
- 调用自身的函数
- 列表

我发现，在大多数递归函数中，base case都是很容易写的：最简单的列表是什么？空列表啊。空列表的长度是0。其次简单的列表是只含有一个元素的列表：`[-]=1`。看起来已经足够写个定义了。

    len([]) -> 0;
    len([_]) -> 1.

帅！这个函数就可以计算列表的长度了，真是个有用的函数。呵呵，当然，这个函数没什么实际用处了。现在我们已经到了最艰难的部分：扩展这个函数的定义以致完全。我们之前说过，列表的定义本身就是递归的，形式如下：`[1 | [2 | ... [n | []]]]`。这就意味着我们可以用`[H|T]`这个模式来匹配列表的头部H和尾部T。如果是单个元素的列表，定义是这样的：`[X|[]]` 如果是两个元素的列表，定义是这样的：`[X|[Y|[]]]`。注意，第二个元素就是一个列表，因此我们只需要注意第一个元素，第二个元素（因为是个列表）所以可以被这个函数再次使用。因为一个元素占用一个列表长度，所以我们可以这么定义：

    len([]) -> 0;
    len([_|T]) -> 1 + len(T).

那么，现在你得到了一个计算列表长度的递归函数。为了了解这个函数 `len/1` 是如何发挥作用的，我们在给定的列表 `[1,2,3,4]` 上使用这个函数。

    len([1,2,3,4]) = len([1 | [2 | [3 | [4 | []]]]])
                   = 1 + len([2 | [3 | [4 | []]]])
                   = 1 + 1 + len([3 | [4 | []]])
                   = 1 + 1 + 1+ len([4 | []])
                   = 1 + 1 + 1 + 1 + len([])
                   = 1 + 1 + 1 + 1 + 0
                   = 1 + 1 + 1 + 1
                   = 1 + 1 + 2
                   = 1 + 3
                   = 4

长度函数的尾递归版本
-------------------------

你可能注意到了，为了一个长度为4的列表，我们使用了5个空间来存储加数。对于短的列表来说，这没什么，但对于几万亿长度的列表来说，这可是个大问题。分配1亿个空间是不必要的，也是不聪明的。现在，让我们进入尾递归的世界。

